import { MediaUdp } from "./MediaUdp.js";
import { type TransportEncryptor } from "../encryptor/TransportEncryptor.js";
import { SupportedEncryptionModes } from "../../utils.js";
import WebSocket from 'ws';
import EventEmitter from "node:events";
import type { Message, GatewayRequest } from "./VoiceMessageTypes.js";
import type { Streamer } from "../Streamer.js";
type VoiceConnectionStatus = {
    hasSession: boolean;
    hasToken: boolean;
    started: boolean;
    resuming: boolean;
};
type WebRtcParameters = {
    address: string;
    port: number;
    audioSsrc: number;
    videoSsrc: number;
    rtxSsrc: number;
    supportedEncryptionModes: SupportedEncryptionModes[];
};
export type VideoAttributes = {
    width: number;
    height: number;
    fps: number;
};
export declare const CodecPayloadType: {
    readonly opus: {
        readonly name: "opus";
        readonly type: "audio";
        readonly priority: 1000;
        readonly payload_type: 120;
    };
    readonly H264: {
        readonly name: "H264";
        readonly type: "video";
        readonly priority: 1000;
        readonly payload_type: 101;
        readonly rtx_payload_type: 102;
        readonly encode: true;
        readonly decode: true;
    };
    readonly H265: {
        readonly name: "H265";
        readonly type: "video";
        readonly priority: 1000;
        readonly payload_type: 103;
        readonly rtx_payload_type: 104;
        readonly encode: true;
        readonly decode: true;
    };
    readonly VP8: {
        readonly name: "VP8";
        readonly type: "video";
        readonly priority: 1000;
        readonly payload_type: 105;
        readonly rtx_payload_type: 106;
        readonly encode: true;
        readonly decode: true;
    };
    readonly VP9: {
        readonly name: "VP9";
        readonly type: "video";
        readonly priority: 1000;
        readonly payload_type: 107;
        readonly rtx_payload_type: 108;
        readonly encode: true;
        readonly decode: true;
    };
    readonly AV1: {
        readonly name: "AV1";
        readonly type: "video";
        readonly priority: 1000;
        readonly payload_type: 109;
        readonly rtx_payload_type: 110;
        readonly encode: true;
        readonly decode: true;
    };
};
export declare abstract class BaseMediaConnection extends EventEmitter {
    private interval;
    udp: MediaUdp;
    guildId: string | null;
    channelId: string;
    botId: string;
    ws: WebSocket | null;
    ready: (udp: MediaUdp) => void;
    status: VoiceConnectionStatus;
    server: string | null;
    token: string | null;
    session_id: string | null;
    webRtcParams: WebRtcParameters | null;
    private _streamer;
    private _transportEncryptor?;
    private _sequenceNumber;
    constructor(streamer: Streamer, guildId: string | null, botId: string, channelId: string, callback: (udp: MediaUdp) => void);
    abstract get serverId(): string | null;
    get type(): "guild" | "call";
    get transportEncryptor(): TransportEncryptor | undefined;
    get streamer(): Streamer;
    stop(): void;
    setSession(session_id: string): void;
    setTokens(server: string, token: string): void;
    start(): void;
    handleReady(d: Message.Ready): void;
    handleProtocolAck(d: Message.SelectProtocolAck): void;
    setupEvents(): void;
    setupHeartbeat(interval: number): void;
    sendOpcode<T extends GatewayRequest>(code: T["op"], data: T["d"]): void;
    identify(): void;
    resume(): void;
    private setProtocols;
    setVideoAttributes(enabled: false): void;
    setVideoAttributes(enabled: true, attr: VideoAttributes): void;
    setSpeaking(speaking: boolean): void;
    sendVoice(): Promise<void>;
}
export {};
