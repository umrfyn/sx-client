'use strict';

var node = require('./node.cjs');
var err = require('./serializers/err.cjs');
var req = require('./serializers/req.cjs');
var res = require('./serializers/res.cjs');

const serializers = {
  err: err.errSerializer,
  req: req.reqSerializer,
  res: res.resSerializer
};

/**
 * @typedef {import('node:http').IncomingMessage} IncomingMessage
 * @typedef {import('node:http').ServerResponse} ServerResponse
 * @typedef {import('./node.js').LogOptions} LogOptions
 *//**
 * @typedef {object} ExtIncomingMessageId
 * @property {string} [id] request Id
 *//**
 * @typedef {IncomingMessage & ExtIncomingMessageId} IncomingMessageWithId
 *//**
 * @typedef {object} ExtLogOptionsHttpLog
 * @property {() => string} [customGenerateRequestId]
 *//**
 * @typedef {LogOptions & ExtLogOptionsHttpLog & {Log: typeof Log}} LogOptionsHttpLog
 */

/**
 * @param {string} [namespace='debug-level:http']
 * @param {LogOptionsHttpLog} [opts]
 * @returns {(req: IncomingMessageWithId, res: ServerResponse, next: Function) => void} connect middleware
 */
function httpLogs (namespace, opts) {
  const options = {
    Log: node.Log,
    ...opts
  };
  options.serializers = {
    ...serializers,
    ...(options.Log.serializers || {}),
    ...(options.serializers || {})
  };

  const log = new options.Log(namespace || 'debug-level:http', options);
  const generateId = options.customGenerateRequestId || generateRequestId;

  return function _httpLogs (req, res$1, next) {
    if (!req.id) {
      req.id = generateId();
    }
    res$1[res.startTimeKey] = res$1[res.startTimeKey] || Date.now();

    const handleComplete = (err) => {
      res$1.removeListener('finish', handleComplete);
      res$1.removeListener('close', handleComplete);
      res$1.removeListener('error', handleComplete);

      const statusCode = res$1.statusCode;
      const level =
        statusCode < 400 ? 'info' : statusCode < 500 ? 'warn' : 'error';

      return log[level]({ req, res: res$1, err })
    };

    res$1.on('finish', handleComplete);
    res$1.on('close', handleComplete);
    res$1.on('error', handleComplete);

    next();
  }
}

const maxCount = (1 << 30) - 1;
let count = 0;
const generateRequestId = () => String((count = (count + 1) & maxCount));

exports.httpLogs = httpLogs;
